# A bind value of 0.0.0.0 means any network this computer can access
# You can chage this to a specfic network e.g. "192.168.1.101" here
# Or to no networks e.g. this computer only "127.0.0.1"
bind = "0.0.0.0"

# Default port is 8554 but you can change it by uncommenting the following
# bind_port = 8554

# Uncomment the following and supply a path to a valid PEM
# to activate TLS encryption.
# The PEM should contain the certificate and the private key
# If TLS is activated you must connect with "rtsps://" and not "rtsp://"
# certificate = "/path/to/pem/with/cert/and/key"

# Choose if the client is required to provide a certificate signed by the server's CA.
# none|requested|required - default none
# tls_client_auth = "required"

# You can password protect the rtsp server mount points by adding users
# like the following me and someone. If you do not add [[users]]
# then anyone can connect without a password or username
# To access such a stream try using a url such as "rtsp://me:mepass@192.168.1.101/driveway"

# [[users]]
# name = "me"
# pass = "mepass"
#
# [[users]]
# name = "someone"
# pass = "someonepass"

# Uncomment to enable MQTT
#[mqtt]
# mqtt.broker_addr = "192.168.1.122"
# mqtt.port = 1883
# mqtt.credentials = ["mqtt_user", "mqtt_password"]


[[cameras]]
name = "driveway"
username = "admin"
password = "12345678"
address = "192.168.1.187:9000"
# MQTT Discovery: https://www.home-assistant.io/integrations/mqtt/#mqtt-discovery
# mqtt.discovery.topic = "homeassistant" # Uncomment to enable
# If using discovery, _ characters are replaced with spaces in the name and title case is applied
# mqtt.discovery.features = ["floodlight"] # Uncomment if this camera has a spotlight/floodlight

# If you use a battery camera: **Instead** of an `address` supply the uid
# as follows
# uid = "ABCD01234567890EFG"

# By default any of the users can connect (or anyone at all if no users are specfied)
# You can uncomment the following to permit only specfic users
# permitted_users = [ "me" ]

# By default "both" "mainStream" and "subStream" are connected
# If your device has user connection limits try a single stream instead.
# stream = "mainStream"

# If your camera streams H.265 but you need H.264 (e.g., for HomeKit compatibility),
# uncomment the following to enable transcoding:
# transcode_to = "h264"
# Note: Transcoding requires additional CPU resources and will add latency

# Optionally specify which encoder to use for transcoding (default: "auto"):
# transcode_device = "auto"      # Auto-detect (try hardware, fallback to software)
# transcode_device = "vaapi"     # Force hardware encoding (VAAPI/Intel Quick Sync)
# transcode_device = "x264"      # Force software encoding (slower, works everywhere)
# transcode_device = "/dev/dri/renderD128"  # Use specific GPU device
# Note: Hardware encoding requires GPU access in Docker (see docs)

# By default neolink will use any means to connect to the camera
# from a UID
# This include relaying via reolink servers
# This variable `discovery` controls the method of UID discovery
# - Possible values
# "relay" # Any means including connecting and transmitting through reolink
# "map" # Register our local ip address with reolink and ask the camera to connect to us but don't relay data through reolink
# "remote" # Register our local ip address with reolink but only permit same network connections (useful if broadcast is not possible)
# "local" # Do not contact reolink servers at all. Rely soley on local UDP broadcast based discovery
#
# "cellular" # Cellular camera only support Relay and Map to speed up connecting to them this option will skip the local/remote
#
# discovery = "relay"

# Certain types of camera emit status messages (such as battery levels)
#
# By default we hide these status messages from the user but you can instead requst that
# they be printed to stdout using print_format
#
# Valid values are:
# - None
# - Human
# - Xml
#
# print_format = "None"


# Example: Argus Battery Camera with H.265 Transcoding and Optimizations
[[cameras]]
name = "backyard_battery"
username = "admin"
password = "password123"
uid = "9527000KJLYHAX9V"  # Battery cameras use UID instead of address

# Enable BOTH streams (mainStream and subStream)
stream = "both"

# Transcode mainStream H.265 â†’ H.264 for better compatibility
# Argus cameras typically send H.265 on mainStream
transcode_to = "h264"

# Optionally specify which encoder to use for transcoding (default: "auto")
# transcode_device = "auto"      # Auto-detect (try hardware, fallback to software)
# transcode_device = "vaapi"     # Force hardware encoding (VAAPI/Intel Quick Sync)
# transcode_device = "x264"      # Force software encoding (slower, works everywhere)
# transcode_device = "/dev/dri/renderD128"  # Use specific GPU device
# Note: Hardware encoding requires GPU access in Docker (see docs)

# Battery camera optimizations (auto-applied if "Argus" detected in model)
idle_disconnect = true          # Disconnect when no activity to save battery
codec_detection_timeout = 60    # Battery cameras need longer to wake up
idle_grace_period = 60          # Wait 60s before disconnecting (default: 30s)
ping_retries = 3                # Faster failure detection
motion_permit_duration = 30     # Keep alive 30s after motion stops

# Advanced: Adaptive grace period learns from usage patterns
# adaptive_grace_period = true

# Advanced: Pre-warming connects camera immediately on motion detection
# prewarm_on_motion = true

# Advanced: Pre-buffer video before motion events (0-30 seconds)
# prebuffer_duration = 5

# Motion-based streaming to save battery
[cameras.pause]
on_motion = true
mode = "none"

# Optional: MQTT for battery level monitoring
# [cameras.mqtt]
# enable_battery = true
# battery_update = 2000  # Update every 2 seconds


[[cameras]]
name = "storage shed"
username = "admin"
password = "987654321"
address = "192.168.1.245:9000"
# If you use a battery camera: **Instead** of an `address` supply the uid
# as follows
# uid = "ABCD01234567890EFG"

# If you use an NVR that relays several camera connections you can choose which
# camera to connect to with by setting the `channel_id`
#
# By default channel_id = 0. Eg the first connected camera on the device
# **Note**: that unlike in the official client the numbering starts from 0 not 1.
# An 8 channel NVR would have channels 0 through 7
# channel_id = 0
